# loadflow の詳細

`loadflow` の全てを理解できるように書いた

#### クラスについて(クラスが分からない場合)

クラスはそのクラスに属する情報(プロパティ)や機能(メソッド)をひとまとめにした雛形である。その雛形からインスタンス(実態)を作るには `クラス名()` のようにする。これを変数に代入すれば変数を通してクラスのインスタンスとしてアクセスできる。インスタンスを作るときに python では `__init__` が呼び出される。その際にクラスに渡したいパラメータがあれば `クラス名(パラメータ)` として渡す。クラス内のメソッドには自動で第一引数としてインスタンスが渡される。そのため、全てのメソッドの第一引数はその目的で使わなければいけない。そのための変数名としては慣例として `self` が使われる。

例:
~~~python

class Phone:
    def __init__(self, number):  # self はインスタンス、number がパラメータ
        self.number = number  # インスタンスのプロパティ self.number にパラメータを代入
        self.size = (2340, 1080)
        self.battery = 100

    def call(self):  # メソッド
        self.battery -= 1  # 電話をかけると充電が1%減る

iphone = Phone('090111222333')  # iphone というインスタンスを作成。__init__ が呼ばれる

print(iphone.number)  # プロパティへのアクセス
>>> 090111222333
print(iphone.battery)
>>> 100

iphone.call()  # 電話をかけた
print(iphone.battery)
>>> 99

iphone.number = '0120117117'  # 番号を変更
print(iphone.number)
>>> 0120117117
~~~

以上が基本である。ただし、上記のように勝手に番号を書き換えられたくないような時は少し工夫がいる。そのためにデコレータという機能を使うのだが、説明すると長くなるから使い方だけを紹介する。

~~~python

class Phone:
    def __init__(self, number):
        self._number = number  # プロパティの名前を_numberに変更
        self.size = (2340, 1080)
        self.battery = 100

    def call(self):
        self.battery -= 1

    @property  # propertyというデコレータを追加
    def number(self):
        return self._number

iphone = Phone('090111222333')

print(iphone.number)
>>> 090111222333  # いつも通り使える

iphone.number = '0120117117'  # これはエラーになる

~~~

上ではプロパティ名を `self.number` を `self._number` に書き換えたから、`self.number` ではアクセスできない。しかし、`number` というメソッドを定義することによって、`number()` で `self._number` を呼び出せるようにしている。このままでもいいが、通常のプロパティのような書き方でアクセスできるようにするために `@property` をその上に追加することができる。これで()をつけなくてよくなったわけである。しかし、プロパティの値を書き換えようとしても `number` というメソッドにはそのような機能がないからエラーになるのである。また、この機能を使うことによってプロパティにアクセスするときに、付加的な操作を実行することができるようになる。例えば `number` の `return` 文の直前に何らかのコードを書けば、値を返す直前に何かの操作をすることができる。これを使って `loadflow` の中の `r` などを対称行列にしている(配列の場合は少しトリッキーなので注意がいるが)。

## PowerSystem クラス

`__init__` ではノード数 `n` をパラメータとして、欲しい形の配列や numpy 配列を初期化している。`r` は全成分が無限大の nxn 行列、`x, b` は全成分が 0 の nxn 行列である。 `bc` は n 成分の１次元の numpy 配列、`P, Q, V, theta` は全成分が `None` の n 成分の通常の配列である。

#### 配列の copy について

配列はメモリ上の一定の領域を確保したものであり、配列を通常の変数のようにコピーしてしまうと、メモリの領域の情報自体がコピーされてしまう。つまり、コピーした配列が参照する領域とコピー元の配列が参照する領域は同一になり、一方を書き換えるともう一方も書き変わってしまう。そのため、 `__init__` の中で `r, x, b` の配列をコピーする際に、`copy.deepcopy` を使用している。こうすることで同じ内容の配列がメモリの別の領域に作られるのである。このコピーは後で使う。

### `r` プロパティについて

`r` は `self._r_copy` を返すのである。これは、`self._r_copy` によって確保されているメモリの領域を返しているのであり、つまり、返ってきた配列の中身を変更できるのである。配列じゃない通常の場合、返ってくる値は値そのもののため、何も変更を加えることができないが、配列の性質のためにそれが可能なのである。従って、`ps.r[i, j]` のようにして、`self._r_copy` の中身を書き換えられる。

一度 `r` にアクセスすることで `self._r_copy` のいづれかの値が書き変わっているとしよう。次に `r` にアクセスするときに、`return` 文の前のコードが実行される。このコードは `self._r` と `self._r_copy` の中の違っている成分のインデックスを取得し、`self._r_copy` の中からそのインデックスの値を引き出し、`self._r` に対称に代入したあと、`self._r` を `deepcopy` したものを `self._r_copy` に代入する。これによって、対称な `self._r` と全く同じ内容の配列を返すことができるわけである。

`np.not_equal(a, b)` は配列 a と b のそれぞれの成分を比較して等しければ `True` を、等しくなければ `False` をその成分に入れた配列を返す。`np.where` は配列の中で `True` になってるインデックスを返す。

`x, b` に関しても同じである。

#### リスト内包表記

python では、`[f(x) for x in xlist]` のようにすることで、配列(やその仲間) `xlist` から `x` に１つずつ値を代入し、`f(x)` にその `x` が代入されたものを成分とする配列を作ることができる。`if` 文と組みあわせることも可能。

##### その他の有用な機能

`xlist` と `ylist` の両方の値を同時に使いたい場合、`[f(x, y) for (x, y) in zip(xlist, ylist)]` とできる。

`xlist` とそのインデックスの両方を使いたい場合、`[f(i, x) for i, x in enumerate(xlist)]` とできる。

`sum(xlist)` は `xlist` の総和を返す

例:

~~~python

[x*2 for x in range(3)]
>>> [0, 2, 4]

xlist = [1, 1, 1]
ylist = [0, 1, 2]

[x+y for (x, y) in zip(xlist, ylist)]
>>> [1, 2, 3]

[ylist[i] + x for i, x in enumerate(xlist)]
>>> [1, 2, 3]

[x for x in ylist if x != 0]
>>> [1, 2]

sum(xlist)
>>> 3
~~~

これが分かれば `_Y_diag` を理解できる。配列の形に注意。`r, x, b` の `i` 行目を取り出した配列の `j` 番目の成分が `i` に等しくない場合に、それらの値からコードの通りの計算値から配列を作成し、最後に全ての `j` について総和をとり、`bc` の `i` 行目と計算したものを返す。これは対角成分１つにつき実行される。

`_Y_nondiag` は `r, x` の各非対角成分それぞれについて、実行され、`Y` の非対角成分を与える。

`Y` は、nxn の全成分が0の複素行列で初期化し、対角成分それぞれに `_Y_diag`、非対角成分に `_Y_nondiag` を足し合わせたものを返す。
`np.diag_indices` により、対角成分のインデックスを取得することができる。これより、全ての対角成分に `_Y_diag` を足すことができる。`np.eye` により、単位行列を作成でき、`np.where(条件, True の時の戻り値, False の時の戻り値)` という構文によって、`_Y_nondiag` の値を非対角成分にだけ足すことができる。

`_initialize_vec` は、既知の P, Q のベクトル `_p` と未知の V, theta のベクトル `_v`、また、
